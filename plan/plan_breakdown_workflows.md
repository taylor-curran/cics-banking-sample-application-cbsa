# Plan: Piece-wise Java Function Implementation Workflows  
Date: 2025-06-13

## 1. Rationale  
1. Long conversations and lengthy tool calls generated by translating a large COBOL program in one gulp overload Cascade’s context window and degrade performance.  
2. Breaking the Java port into small "pieces" (focused methods/helper classes) lets us compile & test each unit immediately, catching errors early.  
3. Each micro-workflow writes its own markdown log so the next step can resume without reloading prior context.

## 2. Directory & File Conventions  
1. **Root Folder per Program**: `workflow_planner/<PROGRAM>/` (e.g., `workflow_planner/INQACC/`).  
2. **Iterative Sub-Folder**: `<PROGRAM>_iterative/` inside the root for all per-piece iterations.  
3. **Static Plan Files (root level)**:  
   1. `1_cobol_function_analysis_<PROGRAM>.md`  
   2. `3_java_function_piece_plan_<PROGRAM>.md`  
4. **Per-Piece Iterative Files (in `<PROGRAM>_iterative/`)**:  
   1. `4_java_function_piece_<PIECE>_<PROGRAM>.md` – Java implementation & unit test loop.  
   2. `5_integration_verify_<PIECE>_<PROGRAM>.md` – end-to-end verification learnings for that piece.  
5. **Publish-Ready Output**: once all pieces pass, aggregate docs can be copied to `plan/completed_migrations/<PROGRAM>/`.  
6. **Ordered Filenames**: every workflow markdown file must be prefixed with its sequence number (e.g., `1_cobol_function_analysis_<PROGRAM>.md`, `2_cobol_function_java_scaffold_<PROGRAM>.md`).

## 3. Top-Level Micro-Workflows  
1. **`1_cobol_function_analysis`**  
   1. Inputs: COBOL source + mapping rules.  
   2. Outputs: type map, naming decisions, high-level design notes.  
   3. Writes: `1_cobol_function_analysis_<PROGRAM>.md`.  
2. **`2_cobol_function_java_scaffold`**  
   1. Preconditions  
      1. Verify that both the COBOL analysis markdown (`1_cobol_function_analysis_<PROGRAM>.md`) and the original COBOL source (`<PROGRAM>.cbl`) are supplied via `@[file]` mentions in the same slash-command invocation.  
      2. If either file is missing, write the result file (see Step 5) with an error summary and the line `STATUS: FAIL`, then stop.  
   2. Inputs: requires `@[workflow_planner/<PROGRAM>/cobol_function_analysis_<PROGRAM>.md]` and `@[src/base/cobol_src/<PROGRAM>.cbl]` to be mentioned in the invocation prompt.  
   3. Generates DTOs, Repository, Service, Controller skeletons, and a MapStruct mapper interface.  
   4. Annotates dev-only beans with `@Profile("!test")` and tags generated classes with `// TODO` placeholders for business logic.  
   5. Writes: `2_cobol_function_java_scaffold_<PROGRAM>.md`.  
3. **`3_java_function_piece_plan`**  
   1. Preconditions  
      1. Verify that both the COBOL analysis markdown (`1_cobol_function_analysis_<PROGRAM>.md`) and the original COBOL source (`<PROGRAM>.cbl`) are supplied via `@[file]` mentions in the same slash-command invocation.  
      2. If either file is missing, write the result file (see Step 4) with an error summary and the line `STATUS: FAIL`, then stop.  
   2. Parses PROCEDURE DIVISION; decides the "piece" boundaries (methods/helper classes). Refer to the **Piece-Boundary Heuristics** (section 6) for the rules used.  
   3. Outputs a checklist table (Piece-A … Piece-N) with inputs/outputs & dependencies.  
   4. Writes: `3_java_function_piece_plan_<PROGRAM>.md`.  
4. **`4_java_function_piece_impl`** *(slash-command: `/java_function_piece_impl` – uses @mentions for context)*  
   1. Preconditions  
      1. Verify that both the COBOL analysis markdown (`1_cobol_function_analysis_<PROGRAM>.md`) and the original COBOL source (`<PROGRAM>.cbl`) are supplied via `@[file]` mentions in the same slash-command invocation.  
      2. If either file is missing, write the result file (see Step 5) with an error summary and the line `STATUS: FAIL`, then stop.  
   2. Generates/modifies Java code for the specified piece.  
   3. Runs `mvn -q test` scoped to piece's unit tests.  
   4. If tests fail, loops within the same workflow until they pass (fail-fast).  
   5. Writes/updates: `4_java_function_piece_<PIECE>_<PROGRAM>.md`.  
5. **`5_java_function_integration_verify`**  
   1. Preconditions  
      1. Verify that both the COBOL analysis markdown (`1_cobol_function_analysis_<PROGRAM>.md`) and the original COBOL source (`<PROGRAM>.cbl`) are supplied via `@[file]` mentions in the same slash-command invocation.  
      2. If either file is missing, write the result file (see Step 4) with an error summary and the line `STATUS: FAIL`, then stop.  
   2. Boots the full Spring app with generated test data.  
   3. Executes API/integration tests across piece boundaries.  
   4. For each failure, logs offending `PIECE` and suggested fix; writes `5_integration_verify_<PIECE>_<PROGRAM>.md` in iterative folder.  

## 4. Invocation Guide  
1. **Prerequisites**  
   1. COBOL program in `src/base/cobol_src/`.  
   2. Mapping rules committed (`cobol_java_type_mapping.md`, `naming_structure.md`).  
   3. Local env: JDK 11+, Maven 3.9+, SQLite3.  
2. **Step-by-Step**  
   1. `/cobol_function_analysis @[src/base/cobol_src/<PROGRAM>.cbl]`  
   2. `/cobol_function_java_scaffold @[workflow_planner/<PROGRAM>/cobol_function_analysis_<PROGRAM>.md] @[src/base/cobol_src/<PROGRAM>.cbl]`  
   3. `/java_function_piece_plan @[workflow_planner/<PROGRAM>/cobol_function_analysis_<PROGRAM>.md]`  
   4. For each row in the checklist run `/java_function_piece_impl @[workflow_planner/<PROGRAM>/_iterative/java_function_piece_<PIECE>_<PROGRAM>.md]` until all pass.  
   5. After each workflow writes its markdown output, **a human reviewer must inspect it and manually trigger the next workflow**; Cascade will not auto-advance.  
   6. Finally run `/java_function_integration_verify` – if failures, revisit the corresponding `piece_impl` workflows.  
   7. *Parameterization note*: slash-commands **do not accept positional parameters**. Supply required inputs by `@[file]` mentions in the same prompt, as illustrated above.  

## 5. Action Items  
1. Create the five workflow markdown templates under `.windsurf/workflows/`.  
2. Implement slash-command handlers (`/java_function_piece_impl`, etc.).  
3. Adjust CI to detect completed migrations by scanning `workflow_planner/<PROGRAM>/_iterative` for all `integration_verify_*` marked **PASS**.  
4. Deprecate `cobol_function_migration.md` by adding a banner linking here.  

## 6. Piece-Boundary Heuristics  
1. COBOL paragraph boundary – each paragraph/section becomes one piece unless it is only an `EXIT.` line.  
2. External interaction – any block that opens/closes a cursor or performs `EXEC SQL`, VSAM, or `EXEC CICS` I/O is isolated in its own piece.  
3. Loop or conditional complexity – if a paragraph exceeds 40 lines or contains deeply nested control flow, split the inner loop into its own helper piece.  
4. Shared Working-Storage structures – paragraphs operating on the same WS fields (mapping to one DTO/entity) stay together; otherwise they split.  
5. Magic-value branches – sentinel branches (e.g., `ACCNO = 99999999`) become dedicated pieces so tests can explicitly target each rule.  
6. Cross-cutting utilities – generic routines (`POPULATE-TIME-DATE`, storm-drain checks) migrate once into shared utility classes (one piece, reused project-wide).  
7. ABEND / error flows – all ABEND handling paragraphs are grouped into a common `*AbendHandler` utility rather than per-piece code.  

## 7. Worked Example: `INQACC.cbl`  

### 7.1 Data Structures → DTO / Entity  
1. `INQACC` commarea → `InqAccDto`  
2. `HOST-ACCOUNT-ROW` → `AccountRowDto`  
3. `OUTPUT-DATA` → `AccountDto`  
4. `ABNDINFO-REC` → `AbendInfo`  

### 7.2 Proposed Piece Checklist  

| Piece | COBOL paragraph(s) | Java artifact(s) | Primary inputs | Primary outputs | External touch-points |
|-------|--------------------|------------------|----------------|-----------------|-----------------------|
| A | `PREMIERE` (`A010`) | `InqAccService.processRequest()` | `InqAccDto` | updated `InqAccDto` | delegates to B–D |
| B | `READ-ACCOUNT-DB2` (`RAD010`) | `AccountRepository.findBySortcodeAndNumber` | sort code, acc # | `AccountEntity` | DB |
| C | `FETCH-DATA` (`FD010`) | `AccountMapper.entityToDto` | `AccountEntity` | `AccountDto` | — |
| D | `READ-ACCOUNT-LAST` / `GET-LAST-ACCOUNT-DB2` | `AccountRepository.findTopBySortcodeOrderByNumberDesc` | sort code | `AccountEntity` | DB |
| E | `CHECK-FOR-STORM-DRAIN-DB2` | `StormDrainUtil.checkDb2` | SQLCode | exception | — |
| F | `POPULATE-TIME-DATE` | `CicsTimeUtil.populate` | — | date/time strings | CICS clock |
| G | `ABEND-HANDLING` | `CicsAbendHandler` | exception | HTTP error / commit | CICS |

### 7.3 Expected Java Artifacts  
1. `InqAccService` (transactional business logic).  
2. `AccountRepository` (Spring Data JPA).  
3. `AccountEntity` (JPA entity).  
4. `AccountMapper` (MapStruct mapper).  
5. `StormDrainUtil` and `CicsAbendHandler` (cross-cutting concerns).  
6. Unit + integration tests: `InqAccServiceTest`, `AccountRepositoryTest`, `StormDrainUtilTest`.  

### 7.4 Workflow Walk-through  
1. `/cobol_function_analysis @[src/base/cobol_src/INQACC.cbl]` – extracts DTOs, constants, error codes.  
2. `/cobol_function_java_scaffold` – scaffolds entity, repository, service, controller, mapper.  
3. `/java_function_piece_plan` – generates the checklist table above.  
4. For each piece A–G run `/java_function_piece_impl` (mention the piece markdown) until its unit tests pass.  
5. `/java_function_integration_verify` – boots Spring on port 8085 with generated data and runs end-to-end tests.  

## 8. Remaining Open Issues  
1. MapStruct processor availability in build image.  
2. Strategy for seeding data for isolated piece tests.  



